1) lower urgency brand + pending: A brand occurs and the system
   decides not to run it due to lesser urgency.  In the end, that
   thread ends up endlessly ignored unless another interrupt happens.
   It appears what's happening is that the event for the thread to
   become active is not being delivered or interpretted at the right
   time, thus the scheduler is unaware the upcall is active.  The
   current work-around is to send a BRAND_PENDING event whenever we
   add a pending brand.  The scheduler will get this event and will
   schedule the thread.  When there are many interrupts, this kind of
   works.

2) brand_higher_urgency, I believe, makes the assumption somewhere
   that an event actually exists for the interrupted thread.  In any
   case, when the interrupted thread only creates the thread, but does
   not setup events for it, we get a page fault in
   brand_higher_urgency+0x2c8 (8c c7 <c7> 05 00).

3) unless a "make" is done to replace modules between runs, cosnet
   (cnet.ko) seems to fault in the interrupt handler bringing the
   machine down hard.  There is just some initialization/finalization
   problem with the cosnet or with its interaction with hijack. OK,
   now it looks like it is just something that persists across page
   faults that is the problem (only if you get page faults across 2
   runs, the second will fail).

4) Unknown reason for this behavior: when we xmit a packet, it can
   (will) generate a softirq, which we should trigger immediately to
   send the packet.  However, when we trigger this softirq, in a path
   were interrupts are disabled, we end up executing net recv/timer
   softirqs.  How/why?

5) stupid that for upcalls that complete and must upcall into the
   scheduler, we use iret.  To change this though, we need to change
   the register layout both in kernel and in component, which is too
   annoying and fickle to do in the middle of trying to get networking
   to work.  Low prio.
